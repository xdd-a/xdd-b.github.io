import{_ as l,p as d,q as u,s as e,R as n,t as a,a2 as o,Y as t,n as r}from"./framework-e1bed10d.js";const p={},h={href:"https://react.iamkasong.com/",target:"_blank",rel:"noopener noreferrer"},k=t(`<h2 id="第一章-react-理念" tabindex="-1"><a class="header-anchor" href="#第一章-react-理念" aria-hidden="true">#</a> 第一章 React 理念</h2><h3 id="react-理念" tabindex="-1"><a class="header-anchor" href="#react-理念" aria-hidden="true">#</a> React 理念</h3><ul><li>JS 脚本执行 与 浏览器渲染是互斥的，会阻塞渲染，</li><li>浏览器渲染 主流的是 60HZ 也就是 1000ms /60 = 16.6ms 刷新一次，如果js脚本执行时间过长，就会导致这一帧无法执行 样式布局 &amp; 样式绘制</li><li>React 通过 unstable_createRoot 来启动 时间切片</li></ul><div class="language-**js** line-numbers-mode" data-ext="**js**"><pre class="language-**js**"><code>
    ReactDom.unstable_createRoot(roolEl).render(&lt;App /&gt;)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>他会将任务切片 分割到多个 task 中，控制了 js 执行时间在 5ms 超出就终止执行，等待下一次继续执行。</li></ul><h3 id="老的react-理念" tabindex="-1"><a class="header-anchor" href="#老的react-理念" aria-hidden="true">#</a> 老的React 理念</h3><h4 id="react-15-架构" tabindex="-1"><a class="header-anchor" href="#react-15-架构" aria-hidden="true">#</a> React 15 架构</h4><ul><li>Reconciler（协调器） 负责找出变化的组件</li><li>Renderer（渲染器）负责将变化的组件渲染到页面上</li></ul><h4 id="react-16-架构" tabindex="-1"><a class="header-anchor" href="#react-16-架构" aria-hidden="true">#</a> React 16 架构</h4><ul><li>Scheduler（调度器）：调度任务的优先级，高优先级的先进入协调器</li><li>Rconciler（协调器）：负责找出变化的组件，然后打上update的标记</li><li>Render（渲染器）：将变化的组件渲染到页面上</li></ul><h4 id="fiber-工作原理" tabindex="-1"><a class="header-anchor" href="#fiber-工作原理" aria-hidden="true">#</a> Fiber 工作原理</h4><ul><li>双缓存树 <ul><li>Current fiber tree 当前渲染的树</li><li>workinprogress fiber tree 工作进程中的树</li><li>当在内存中构建的树构建完成时，current的指针就会执行workinprogress fiber tree 来完成两个树之间的切换</li></ul></li><li>mount时构建替换流程 <ul><li>第一次执行 <code>ReactDOM.render</code> 会创建一个整个应用根节点 <code>fiberRoot</code> 和 组件的根节点 <code>rootFiber</code></li><li><code>fiberRoot</code> 的 current 会指向 <code>rootFiber</code> 因为是第一次还没走到render 所以没有任何的子节点</li><li>执行render 会创建一个 <code>workinprogress fiber tree</code> 构建中的树，当构建完成之后 会将 应用的根节点的 current 指向 <code>workinprogress fiber tree</code> 从而完成更新替换。</li><li>每当有状态更新时，都会先创建一个 <code>workinprogress fiber tree</code> 等待构建完成，在替换current的指向，从而完成更新渲染。</li></ul></li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><ul><li><code>Reconciler</code> 协调器，相当于 <code>render</code> 阶段 他会调用组件的render方法</li><li><code>Renderer</code> 渲染器 相当于 <code>commit</code> 阶段 他会将需要渲染的东西提交渲染到页面上</li></ul><h2 id="fiber-节点-如何创建-fiber-树" tabindex="-1"><a class="header-anchor" href="#fiber-节点-如何创建-fiber-树" aria-hidden="true">#</a> Fiber 节点 如何创建 Fiber 树</h2><ul><li>在 <code>render</code> 阶段，会调用 <code>performSyncWorkOnRoot</code> 或者 <code>performConcurrentWorkOnRoot</code> 这两个方法，来判断本次更新是同步更新还是异步更新。</li><li>其内部会调用以下两个方法</li></ul>`,16),f=e("div",{class:"language-javascript line-numbers-mode","data-ext":"js"},[e("pre",{class:"language-javascript"},[e("code",null,[e("span",{class:"token keyword"},"function"),n(),e("span",{class:"token function"},"workLoopSync"),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},")"),n(),e("span",{class:"token punctuation"},"{"),n(`
  `),e("span",{class:"token keyword"},"while"),n(),e("span",{class:"token punctuation"},"("),n("workInProgress "),e("span",{class:"token operator"},"!=="),n(),e("span",{class:"token keyword"},"null"),e("span",{class:"token punctuation"},")"),n(),e("span",{class:"token punctuation"},"{"),n(`
    `),e("span",{class:"token function"},"performUnitOfWork"),e("span",{class:"token punctuation"},"("),n("workInProgress"),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},";"),n(`
  `),e("span",{class:"token punctuation"},"}"),n(`
`),e("span",{class:"token punctuation"},"}"),n(`
`)])]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),b=e("div",{class:"language-javascript line-numbers-mode","data-ext":"js"},[e("pre",{class:"language-javascript"},[e("code",null,[e("span",{class:"token keyword"},"function"),n(),e("span",{class:"token function"},"workLoopConcurrent"),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},")"),n(),e("span",{class:"token punctuation"},"{"),n(`
  `),e("span",{class:"token keyword"},"while"),n(),e("span",{class:"token punctuation"},"("),n("workInProgress "),e("span",{class:"token operator"},"!=="),n(),e("span",{class:"token keyword"},"null"),n(),e("span",{class:"token operator"},"&&"),n(),e("span",{class:"token operator"},"!"),e("span",{class:"token function"},"shouldYield"),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},")"),n(),e("span",{class:"token punctuation"},"{"),n(`
    `),e("span",{class:"token function"},"performUnitOfWork"),e("span",{class:"token punctuation"},"("),n("workInProgress"),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},";"),n(`
  `),e("span",{class:"token punctuation"},"}"),n(`
`),e("span",{class:"token punctuation"},"}"),n(`
`)])]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),m=t('<ul><li>可以看到他们唯一的区别就是 <code>shouldYield</code> 方法，用来判断浏览器是否有空余时间，用于 <code>react</code> 的更新，如果没有就跳出循环，等待下次调度</li><li><code>performUnitOfWork</code> 方法会创建下一个 <code>Fiber</code> 节点 并赋值给 <code>workInProgress</code> 并将现在的和之前创建好的节点连接起来构建成 <code>Fiber</code> 树</li><li><code>performUnitOfWork</code> 工作其实就是 递 与 归，那么他们又是怎么执行的呢？</li></ul><h3 id="递" tabindex="-1"><a class="header-anchor" href="#递" aria-hidden="true">#</a> “递”</h3><ul><li>会从根节点开始，深度优先遍历，一直到最后一个子集，遍历的时候会调用每个子集的 <code>beginwork</code> , 主要</li></ul>',3);function _(v,g){const c=r("ExternalLinkIcon"),s=r("CodeGroupItem"),i=r("CodeGroup");return d(),u("div",null,[e("p",null,[e("a",h,[n("参考文献"),a(c)])]),k,a(i,null,{default:o(()=>[a(s,{title:"performSyncWorkOnRoot"},{default:o(()=>[f]),_:1}),a(s,{title:"performConcurrentWorkOnRoot"},{default:o(()=>[b]),_:1})]),_:1}),m])}const w=l(p,[["render",_],["__file","react-source.html.vue"]]);export{w as default};

import{_ as t,p,q as c,s as n,R as s,t as e,Y as o,n as l}from"./framework-e1bed10d.js";const i="/assets/fiber-node-3486da0c.jpg",r="/assets/beginWork-36791f11.jpg",d="/assets/completeWork-d91a1bb7.jpg",u={},k=n("h2",{id:"前言",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#前言","aria-hidden":"true"},"#"),s(" 前言")],-1),m=n("p",null,"React 在版本 15 与 16 有比较大的更改，那么这么大费周章的重构一定有存在了以前架构无法解决的痛点了。",-1),v=n("p",null,"现代的前端开发框架之间竞争非常激烈，React 想要稳固他的地位，那么提升 React 的性能是躲不过的事情。",-1),b=n("h2",{id:"一、16、17、18-版本更新了什么",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#一、16、17、18-版本更新了什么","aria-hidden":"true"},"#"),s(" 一、16、17、18 版本更新了什么？")],-1),g=n("li",null,"16.0.0 更改底层架构，采用 Fiber，提出异步渲染",-1),y={href:"https://github.com/facebook/react/blob/main/packages/react-reconciler/README.md",target:"_blank",rel:"noopener noreferrer"},w=o("<li>... 迭代更新</li><li>16.6.0 推出了实验性的 <strong>Scheduler</strong></li><li>16.7.0 更新 Scheduler，正常迭代...</li><li>16.8.0 正式推出 Hook</li><li>... 迭代更新</li><li>16.13.0 实验性的 <strong>Concurrent Mode</strong>，<code>ReactDOM.createRoot()</code></li><li>17.0.0 垫脚石版本，鼓励用户渐进式升级 <ul><li>改变了 React 事件委托对象，以前是 document 现改为 React 容器根节点</li><li>移除了事件池</li><li>异步执行 <code>useEffect</code> 的 cleanup</li></ul></li><li>18.0.0 主要是正式上线了 <strong>Concurrent Mode</strong>（并发模式） <ul><li>自动批处理—以前只有 React 的事件才会批处理，而被 <code>setTimeout</code> 等原生 js 语法包裹的事件无法批处理。</li><li>过渡更新—推出 <code>startTransition</code> 告诉 React 哪些需要进行<em>过渡更新</em>，而不是<em>紧急更新</em></li><li>Suspense 更加方便</li><li>新的 Hook：<code>useId</code>、<code>useTransition</code>、<code>useDeferredValue</code>、<code>useSyncExternalStore</code>、<code>useInsertionEffect</code></li></ul></li>",8),h=n("p",null,[s("⚠️注意：React 默认不会开启 "),n("strong",null,"Concurrent Mode")],-1),f=n("h2",{id:"二、为什么-react-要更新底层架构",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#二、为什么-react-要更新底层架构","aria-hidden":"true"},"#"),s(" 二、为什么 React 要更新底层架构？")],-1),x=n("p",null,[s("要想搞清楚这个问题，那么必须知道 React 是如何将"),n("em",null,"元素"),s("渲染到页面中的（包括如何更新）。")],-1),C=n("p",null,"就从 15 版本看：",-1),_=n("code",null,"stack-reconciler",-1),R={href:"https://zh-hans.legacy.reactjs.org/docs/implementation-notes.html",target:"_blank",rel:"noopener noreferrer"},F=n("li",null,"Rerender—渲染",-1),P=o(`<p>以上两个便是 React 内部工作的核心，它们一个负责处理逻辑，一个负责渲染，各司其职，很美妙对不对。</p><p>但是，这是因为这样简单的结构导致 React 面对庞大数据量以及复杂交互时显得手忙脚乱（掉帧）。我们从一个简单的例子看起：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>  <span class="token comment">// 想象一个简单的列表渲染以及更新</span>
  <span class="token comment">// [1, 2, 3]</span>
  <span class="token comment">// 渲染：</span>
  <span class="token comment">//   reconciler 发现 1 并且知道了它应该渲染成什么样子，一切处理好后告诉 rerender 该渲染了，rerender 乖乖执行渲染</span>
  <span class="token comment">//   reconciler 处理 2，rerender 渲染</span>
  <span class="token comment">//   reconciler 处理 3，rerender 渲染</span>
  <span class="token comment">// 一切看起来不错～</span>
  <span class="token comment">// 这时候，用户下发了乘法指令，所有数字乘以 2，此时变为了 [2, 4, 6]</span>
  <span class="token comment">// 更新：</span>
  <span class="token comment">//   reconciler 发现原本为 1 的元素变为了 2，和之前不同，他兢兢业业处理好一切后告诉 rerender 该渲染了，rerender 乖乖执行渲染</span>
  <span class="token comment">//   reconciler 处理 4，rerender 渲染</span>
  <span class="token comment">//   reconciler 处理 6，rerender 渲染</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的例子我们看起来也没什么问题，逻辑简洁清晰，但是如果用户的操作变多、数据量变大那么会出现什么情况呢？</p><blockquote><p>tips：浏览器是一帧一帧的渲染，即每一帧会处理 JS 逻辑、样式布局、样式绘制。</p></blockquote><p>我们知道一般浏览器的刷新频率为 60Hz，即每（1000ms / 60Hz）16.6ms 浏览器刷新一次。</p><p>也就是说我们在这 16.6ms 中完成上述的一系列操作（JS 逻辑处理、样式布局、样式绘制），用户并不会有任何不适（除非你的眼睛和普通人不同）。</p><p>但是，由于数据量增大，我们的处理逻辑（JS 逻辑）占用了大量时间导致超过了 16.6ms，这时也就让用户感受到了不适。</p><p>虽然这时候的架构会导致掉帧，那我们可以进行优化呀，emmm，的确如此，我们做开发首先想到的是<em>如何优化原有逻辑</em>。</p><p>那么我们来尝试优化下：</p><ul><li>reconciler 长时间执行会导致掉帧，那我们就把他改为可以中断的执行，每一帧留给 JS 执行一定时间去执行，如果执行不完就放到下一帧去完成</li><li>rerender 逻辑不太好，我们优化为一次性更新，由 reconciler 全部处理完毕后统一渲染，这样也不会导致由于被中断的执行导致渲染不一致</li></ul><p>嗯，上面的优化很合理，但是实际上我们的 reconciler 采用的是递归的方式执行，我们都知道递归一旦运行就无法暂停（即便可以退出递归，但是无法保证下次继续执行）。</p><p>直到此，我们无计可施，于是 React 决定重构底层架构。</p><h2 id="三、fiber-架构" tabindex="-1"><a class="header-anchor" href="#三、fiber-架构" aria-hidden="true">#</a> 三、Fiber 架构</h2><p>从上一节我们知道，原本的 <code>stack-reconciler</code> 无法解决 React 高性能优化的需求；所以，React 推出了 <code>fiber-reconciler</code>，并且他的主要目标就是：</p><ul><li>能够中断任务且把任务切片化执行</li><li>能够调整优先级，重置并复用任务</li><li>能够在父元素与子元素之间交错处理，以支持 React 中的布局</li><li>能够在 <code>render()</code> 中返回多个元素（<code>return [&lt;Comp1/&gt;, &lt;Comp2/&gt;]</code>）</li><li>更好地支持错误边界</li></ul><p>那我们知道了新架构的目标，对于新架构的变化就更加清晰了，接下来我就来梳理下 Fiber 架构有哪些内容。</p>`,17),E={href:"https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiber.js",target:"_blank",rel:"noopener noreferrer"},I=o(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>
<span class="token doc-comment comment">/**
 * HTML nodeType values that represent the type of the node
 */</span>
<span class="token keyword">var</span> <span class="token constant">ELEMENT_NODE</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token constant">TEXT_NODE</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token constant">COMMENT_NODE</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token constant">DOCUMENT_NODE</span> <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token constant">DOCUMENT_TYPE_NODE</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token constant">DOCUMENT_FRAGMENT_NODE</span> <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>

<span class="token comment">// WorkTag</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> FunctionComponent <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> ClassComponent <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> IndeterminateComponent <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// Before we know whether it is function or class</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> HostRoot <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// Root of a host tree. Could be nested inside another node.</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> HostPortal <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// A subtree. Could be an entry point to a different renderer.</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> HostComponent <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> HostText <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Fragment <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Mode <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> ContextConsumer <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> ContextProvider <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> ForwardRef <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Profiler <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> SuspenseComponent <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> MemoComponent <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> SimpleMemoComponent <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> LazyComponent <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> IncompleteClassComponent <span class="token operator">=</span> <span class="token number">17</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> DehydratedFragment <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> SuspenseListComponent <span class="token operator">=</span> <span class="token number">19</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> ScopeComponent <span class="token operator">=</span> <span class="token number">21</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> OffscreenComponent <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> LegacyHiddenComponent <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> CacheComponent <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> TracingMarkerComponent <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> HostHoistable <span class="token operator">=</span> <span class="token number">26</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> HostSingleton <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">FiberNode</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token keyword">this</span><span class="token operator">:</span> $FlowFixMe<span class="token punctuation">,</span>
  <span class="token literal-property property">tag</span><span class="token operator">:</span> WorkTag<span class="token punctuation">,</span>
  <span class="token literal-property property">pendingProps</span><span class="token operator">:</span> mixed<span class="token punctuation">,</span>
  <span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> string<span class="token punctuation">,</span>
  <span class="token literal-property property">mode</span><span class="token operator">:</span> TypeOfMode<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token doc-comment comment">/** 作为静态数据结构的属性 */</span>
  <span class="token comment">// Fiber对应组件的类型 Function/Class/Host...</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag<span class="token punctuation">;</span>
  <span class="token comment">// key属性</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
  <span class="token comment">// 大部分情况同 type，某些情况不同，比如 FunctionComponent 使用 React.memo 包裹</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>elementType <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token comment">// 对于 FunctionComponent，指函数本身，对于 ClassComponent，指 class，对于 HostComponent，指 DOM 节点 tagName</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token comment">// Fiber对应的真实 DOM 节点</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>stateNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token doc-comment comment">/** 用于连接其他 Fiber 节点形成 Fiber 树（链表结构）*/</span>
  <span class="token comment">// 指向父级Fiber节点</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>return <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token comment">// 指向子Fiber节点</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token comment">// 指向右边第一个兄弟Fiber节点</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>ref <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>refCleanup <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token doc-comment comment">/** 作为动态的工作单元的属性 */</span>
  <span class="token comment">// 保存本次更新造成的状态改变相关信息</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>pendingProps <span class="token operator">=</span> pendingProps<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>memoizedProps <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>dependencies <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>mode <span class="token operator">=</span> mode<span class="token punctuation">;</span>

  <span class="token comment">// 保存本次更新会造成的DOM操作</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>flags <span class="token operator">=</span> NoFlags<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>subtreeFlags <span class="token operator">=</span> NoFlags<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>deletions <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 调度优先级相关</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>lanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>childLanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>

  <span class="token comment">// 指向该 fiber 在另一次更新时对应的 fiber</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>alternate <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面 Fiber 的结构分析来对应如何实现上面所述的<em>目标</em>：</p><ul><li>能够中断任务且把任务切片化执行 =&gt; 用于连接其他 Fiber 节点形成 Fiber 树（链表结构）</li><li>能够调整优先级，重置并复用任务 =&gt; 调度优先级相关</li><li>能够在父元素与子元素之间交错处理，以支持 React 中的布局 =&gt; 得益于渲染方式的改变以及可中断的任务</li><li>能够在 <code>render()</code> 中返回多个元素（<code>return [&lt;Comp1/&gt;, &lt;Comp2/&gt;]</code>） =&gt; 数据结构的改变（<code>sibling</code> 字段）</li></ul><h3 id="fiber-节点之间的连接" tabindex="-1"><a class="header-anchor" href="#fiber-节点之间的连接" aria-hidden="true">#</a> Fiber 节点之间的连接</h3><div class="language-tsx line-numbers-mode" data-ext="tsx"><pre class="language-tsx"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">你好</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">xdd</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它们解析为 Fiber 结构，如图：</p><p><img src="`+i+`" alt="fiber-node"></p><h3 id="完整的流程" tabindex="-1"><a class="header-anchor" href="#完整的流程" aria-hidden="true">#</a> 完整的流程</h3><p>初始化渲染：</p><ul><li><p>走 <code>legacyRenderSubtreeIntoContainer</code> 方法，如果没有缓存的 root 容器，使用 <code>legacyCreateRootFromDOMContainer</code> 方法创建 root 容器</p><ul><li>会设置优先级为最高</li><li>初始化更新队列 <code>updateQueue</code></li></ul></li><li><p>走 <code>updateContainer</code> 方法，加入更新队列，设置好优先级</p><ul><li><code>payload</code> 是 <code>element</code></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">flushSync</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">updateContainer</span><span class="token punctuation">(</span>initialChildren<span class="token punctuation">,</span> _root<span class="token punctuation">,</span> parentComponent<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>走 <code>scheduleUpdateOnFiber</code> 将更新回调（<code>performSyncWorkOnRoot</code> 方法）加入调度队列</p><ul><li><code>ensureRootIsScheduled</code> 该方法是重点，保证 root 容器可以被调度</li></ul></li><li><p>走 <code>flushSyncCallbacks</code> 执行同步调度队列（优先级最高的）</p></li><li><p>走 <code>performSyncWorkOnRoot</code></p><ul><li><code>var exitStatus = renderRootSync(root, lanes);</code> 需要拿到退出的状态</li></ul></li><li><p>走 <code>renderRootSync</code> 同步进行 <code>render</code> 阶段，拿到退出状态</p><ul><li>期间会走 <code>prepareFreshStack</code> 创建工作进程（<code>workInProgress</code>）</li><li>完成更新队列，并重新赋值下次更新队列</li></ul></li><li><p>走 <code>workLoopSync</code>，该工作是 <code>render</code> 阶段的重点，会遍历一边 Fiber 链表</p><ul><li>顺着上面构建的 <code>workInProgress</code> 来进行遍历</li></ul></li><li><p>走 <code>performUnitOfWork</code> 方法</p><ul><li><code>beginWork</code> 深度优先，完成第一个最深节点后进行 <code>completeUnitOfWork</code> 工作</li><li><code>completeUnitOfWork</code> 完成工作，遇到 sibling 需要继续返回 <code>beginWork</code> 工作</li></ul></li><li><p><code>commit</code> 阶段</p></li></ul><h4 id="beginwork-做了什么" tabindex="-1"><a class="header-anchor" href="#beginwork-做了什么" aria-hidden="true">#</a> <code>beginWork</code> 做了什么？</h4><p>调用 <code>beginWork</code> 时需要传入 <code>current</code>、<code>workInProgress</code>、<code>renderLanes</code> 这三个参数</p><ul><li><code>current</code> 当前的 Fiber 节点，其实就是 <code>workInProgress.alternate</code> 内容，也就是说在 <code>update</code> 时会复用的节点</li><li><code>workInProgress</code> 很熟悉了，这个就是目前正在进行中的 Fiber</li><li><code>renderLanes</code> 优先级相关</li></ul><p>我们就初次渲染来看，<code>current</code> 不为空，那么就进入到了 <code>update</code> 逻辑，因为是初次渲染，也没有 <code>props</code> 与 <code>context</code> 的变化，一顿判断后来到关键逻辑，判断 Fiber 的类型， 根节点的类型为 <code>HostRoot</code> 也就是 3，就来到了 <code>updateHostRoot</code> 逻辑。</p><p><strong><code>updateHostRoot</code></strong> 逻辑：</p><ul><li><p><code>pushHostRootContext(workInProgress)</code> 建立维护 Context 与根容器（Container）的栈结构关系（包括 Protals 节点）</p><ul><li>Context 通过维护栈来管理 Fiber 复杂的父子关系值</li></ul></li><li><p><code>reconcileChildren</code> 内部同样有 <code>mount</code> 与 <code>update</code> 逻辑，但是它们内部方法一样</p><ul><li>协调算法，判断该节点是否可以复用或者要被删除等（diff）</li><li>标记插入、移动、删除、更新，便于后续渲染节点的操作</li></ul></li><li><p>构建好了下一个节点返回执行栈</p></li></ul><p>总结下 <code>beginWork</code> 的逻辑：</p><ul><li>判断是否首次渲染</li><li>更新 <ul><li>判断是否可以复用</li><li>可以复用的话继续下面的逻辑，不可以复用的话跳出当前判断逻辑继续执行</li><li>可以就判断子节点是否需要更新</li><li>需要的话就返回该节点</li><li>不需要的话就跳过</li></ul></li><li>首次渲染 <ul><li>需要构建节点</li></ul></li><li>判断节点的类型（<code>workInProgress.tag</code>） <ul><li>根据节点类型不同会执行对应逻辑，上面的 <code>updateHostRoot</code> 就是其中一个</li><li><code>reconcileChildren</code> 对应 <code>mountChildFibers(workInProgress, null, nextChildren, renderLanes);</code> 和 <code>reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);</code> 渲染或者更新，参考上面的逻辑</li></ul></li><li>构建好下一个 <code>workInProgress</code></li></ul><p>流程图如下：</p><p><img src="`+r+`" alt="beginWork"></p><h4 id="completeunitofwork-做了什么" tabindex="-1"><a class="header-anchor" href="#completeunitofwork-做了什么" aria-hidden="true">#</a> <code>completeUnitOfWork</code> 做了什么？</h4><ul><li>先判断是否有更紧急任务（<code>workInProgress.flag</code> 为 <code>Incomplete</code>），如果没有进入当前节点的“<code>completeWork</code>（完成工作）”，如果有则要跳过</li><li><code>completeWork</code> 阶段 <ul><li>同样判断节点的类型（<code>workInProgress.tag</code>）</li><li>判断是 update 还是 mount，进入不同逻辑</li><li>如果是 mount 的话，则会创建实例，并且将节点插入构成 Fiber 树，等待 <code>commit</code> 阶段渲染为真实 DOM</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>  <span class="token keyword">var</span> _rootContainerInstance <span class="token operator">=</span> <span class="token function">getRootHostContainer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token function">createInstance</span><span class="token punctuation">(</span>_type<span class="token punctuation">,</span> newProps<span class="token punctuation">,</span> _rootContainerInstance<span class="token punctuation">,</span> _currentHostContext<span class="token punctuation">,</span> workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">appendAllChildren</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  workInProgress<span class="token punctuation">.</span>stateNode <span class="token operator">=</span> instance<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>如果是 update 的话，则会生成 <code>updatePayload</code>，并且赋值 <code>workInProgress.updateQueue = updatePayload</code>（这部分是处理<code>onClick</code>、<code>style prop</code>、<code>DANGEROUSLY_SET_INNER_HTML prop</code>、<code>children prop</code>）</li><li>最后 <code>bubbleProperties(workInProgress)</code></li></ul></li><li>判断当前节点是否存在 sibling 节点，如果有的话要继续进入 sibling 节点的 <code>beginWork</code> 工作</li></ul><p>流程图如下：</p><p><img src="`+d+`" alt="completeUnitOfWork"></p><h4 id="commit-阶段做了什么" tabindex="-1"><a class="header-anchor" href="#commit-阶段做了什么" aria-hidden="true">#</a> <code>commit</code> 阶段做了什么？</h4><ul><li><code>rootDoesHavePassiveEffects</code> 存在就执行 <code>flushPassiveEffects()</code></li><li><code>commitBeforeMutationEffects()</code> before mutation 阶段</li><li><code>commitMutationEffects()</code> mutation 阶段，主要是渲染真实 DOM</li><li><code>commitLayoutEffects()</code> layout 阶段，执行 layout Effect</li><li><code>onCommitRoot()</code> ？？</li></ul><p>疑问：</p><ol><li>如何构建 <code>workInProgress</code> ===&gt; 调用 <code>createWorkInProgress()</code> 方法</li></ol><ul><li><code>workInProgress.alternate = current;</code> 缓存该节点（第一次渲染时会缓存根节点）</li></ul><ol start="2"><li>谁去调用 <code>workLoopSync</code>，为什么会执行两次 ===&gt; 错❌，并没有调用两次；只是内部执行 <code>var children = Component(props, secondArg);</code>。</li><li><code>alternate</code> 字段什么含义？相当于节点的缓存 ✅</li><li><code>beginWork()</code> 做了什么？✅</li><li>初次渲染时进入 <code>beginWork</code> 会进入 <code>update</code> 逻辑，这是因为在创建 <code>workInProgress</code> 时缓存了根节点</li><li><code>reconcileChildren()</code> 做了什么？（协调算法，初次渲染直接 mount 全部，更新时需要研究 diff 算法）</li><li><code>rootDoesHavePassiveEffects</code> 这个变量什么时候赋值的？执行 Effect 之前会判断是否有正在进行的 Effect</li><li><code>onCommitRoot()</code> 做了什么？</li></ol><p>收获点：</p><ol><li>Google Closure Compiler - <code>/** @noinline */</code> 对应可以让该函数不被内联结构</li><li></li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token literal-property property">loop1</span><span class="token operator">:</span> <span class="token keyword">do</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">&#39;xdd&#39;</span><span class="token operator">:</span>
      <span class="token comment">// do something</span>
      <span class="token keyword">break</span> loop1<span class="token punctuation">;</span> <span class="token comment">// 可以直接退出 do...while 循环</span>
    <span class="token keyword">case</span> <span class="token string">&#39;xdd&#39;</span><span class="token operator">:</span>
      <span class="token comment">// do something</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 只能退出 switch 语句</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 退出 do...while 循环</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>React18 初始化渲染时不会开启切片/并发模式（不论是否用 createRoot 方法渲染），更新时需要用到某些 API 才能开启并发模式，例如：<code>startTransition</code></li></ol><div class="language-tsx line-numbers-mode" data-ext="tsx"><pre class="language-tsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> startTransition <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>len<span class="token punctuation">,</span> setLen<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 模拟加载数据后更新列表</span>
  <span class="token keyword">function</span> <span class="token function">loadData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">startTransition</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">setLen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>loadData<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Load Data</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token punctuation">{</span><span class="token function">Array</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>i<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>i<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
          <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,35);function S(M,O){const a=l("ExternalLinkIcon");return p(),c("div",null,[k,m,v,b,n("ul",null,[g,n("li",null,[s("16.1.0 推出了实验性的 "),n("a",y,[s("react-reconciler"),e(a)]),s(" 包提供用户自定义 renderers")]),w]),h,f,x,C,n("ul",null,[n("li",null,[s("Reconciler—构建VDOM，准确来说 15 版本用的是 "),_,n("ul",null,[n("li",null,[n("a",R,[s("实现stack-reconciler"),e(a)])])])]),F]),P,n("p",null,[s("先一起来看看 "),n("a",E,[s("Fiber"),e(a)]),s(" 的结构：")]),I])}const D=t(u,[["render",S],["__file","react-core.html.vue"]]);export{D as default};
